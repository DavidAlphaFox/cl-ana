\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename MANUAL.info
@settitle cl-ana Manual
@c %**end of header

@c Settings
@paragraphindent none

@copying
This is the documentation for cl-ana.

Copyright @copyright{} 2013-2015 Gary Hollis
@end copying

@titlepage
@title cl-ana Manual and User's Guide
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top cl-ana Manual

This is the manual and user's guide for cl-ana, a free (GPL) Common
Lisp data analysis library.

Contact the project maintainer Gary Hollis at: ghollisjr@@gmail.com

This documentation is distributed with the source code as well as on
the github webpage: www.github.com/ghollisjr/cl-ana

@end ifnottex

@menu
* Features::            Description of provided functionality
* Installation::        Installation
* User's Guide::        Tutorial-style user's guide
* Manual::              Complete manual
* Index::               Index
@end menu

@node Features
@chapter Features
@cindex Features

cl-ana is built in two layers.  The lowest layer is extendible via
defining classes or methods of generic functions and supports:

@itemize
@item
Generic math: Comes with MATLAB-like array mathematics and is
extendable.

@item
Tabular data analysis: Supports reading datasets stored in HDF5 files,
Ntuple files as used by CERN's PAW and GSL, CSV files, and can be
extended.

@item
Binned data analysis: Supports various kinds of histograms and
arithmetic on histograms.

@item
Plotting: Provides a Lisp interface to gnuplot and comes with methods
predefined for various data types.

@item
Nonlinear least-squares fitting: Provides a clean front end to the
fitting capabilities of GSLL and comes with methods predefined for
various data types.
@end itemize

The higher level provides a data analysis environment with dependency
management, transparent result logging, and the ability to define
special operators which allow definition of powerful operators and
optimizations.  At the time of the writing of this manual, there is a
significant gap between the capabilities of widely available software
which supports small datasets versus large datasets.  Spreadsheet
software provides dependency management (e.g. recalculation based on
changed definitions) and logging of computations to disk without
having to explicitly program these abilities into the spreadsheet
``program'', while at the moment the tools available for large
datasets are more or less compilers and text editors (i.e. you have to
write your own code).

cl-ana bridges this gap by providing not only dependency management
and result logging, but also a novel approach to exposing the compiler
to the user which allows for powerful new operators and optimizations:
the transformation pipeline.  The user selects whatever optimizations
or special operators he/she wishes to use in a project, and can define
custom transformations as well.  The most notable transformations
included with cl-ana are:

@itemize
@item
makeres-table: Provides optimizations and operators for processing
tabular data.  Supports all table types from the low level of cl-ana.

@item
makeres-branch: Provides branching computations, i.e. parallel
computations with automatic collection and classification of results.
@end itemize

The related project makeres-cpp provides a transformation which
provides analogous operators to those in makeres-table, but which
allows orders of magnitude faster code by generating C++ code and
utilizing CERN's ROOT to provide basic analysis functionality as
opposed to cl-ana's lower level.  Automatic conversion between results
calculated in the C++ programs is provided for histograms, lists, and
can be extended to other types.

@node Installation
@chapter Installation
@cindex Installation

cl-ana is Common Lisp software, so you need a Common Lisp
implementation.  The author strongly recommends SBCL
(http://www.sbcl.org/), which is available for Linux and easily
installed for many distributions, although there are many fine
implementations available for download or purchase.

The non-Lisp dependencies are:

@itemize
@item
HDF5 (https://www.hdfgroup.org/HDF5/)
@item
GSL (http://www.gnu.org/software/gsl/)
@item
gnuplot (http://www.gnuplot.info/)
@end itemize

The Lisp dependencies are:

@itemize
@item
CFFI (http://common-lisp.net/project/cffi/)
@item
GSLL (http://common-lisp.net/project/gsll/)
@item
Alexandria (http://common-lisp.net/project/alexandria/)
@item
iterate (http://common-lisp.net/project/iterate/)
@item
antik (http://www.common-lisp.net/project/antik/)
@item
closer-mop (http://common-lisp.net/project/closer/closer-mop.html)
@item
cl-csv (https://github.com/AccelerationNet/cl-csv)
@item
gnuplot (http://www.gnuplot.info/)
@item
cl-fad (http://weitz.de/cl-fad/)
@item
external-program (http://github.com/sellout/external-program)
@end itemize

The easiest way to install the Lisp dependencies is via quicklisp
(http://www.quicklisp.org/).  The install.lisp can be loaded into your
Lisp image once you've installed quicklisp and will automatically
install all the Lisp components of cl-ana via quicklisp.

cl-ana itself is available via quicklisp, which normally provides
appropriately up-to-date software, but since cl-ana is under rapid
development it is often out of date.  Therefore the easiest method is
to use the install.lisp file once you've installed quicklisp.

Note: libffi (https://sourceware.org/libffi/) is required at least by CFFI

@node User's Guide
@chapter User's Guide
@cindex User's Guide

cl-ana is Common Lisp software, which means that the vast majority of
people for whom it would be a useful library don't know the language.
Therefore, this guide combines information about how to use cl-ana
specifically as well as the basics of Lisp and how to use widely
available free tools to best effect.

Peter Seibel's @i{Practical Common Lisp}
(http://www.gigamonkeys.com/book/) is hands-down the best single
resource for starting to learn Common Lisp I've come across.  Paul
Graham's @i{On Lisp} (http://www.paulgraham.com/onlisp.html) teaches
you how powerful macros can be, and Doug Hoyte's @i{Let Over Lambda}
(http://letoverlambda.com/) provides additional examples of how you
can use Common Lisp's features creatively to powerful effect.
Supplementing the information in these books with your search engine
of choice and the will to learn will make you a capable Lisp
programmer.

What follows is humorous experience that may result in one learning
how to make use of Common Lisp and cl-ana.

@menu
@c Basic information on lisp, e.g. REPL, etc.
* Hazing::                 For those uninitiated in the Lisp dark arts
@c Commonly used software, e.g. Emacs + SLIME, SBCL, etc.
* Armory::                 The weapons of war
@c Basic Lisp programming
* Basic Training::         This is my rifle, this is my gun
@c Macros
* Red Pill::               See the matrix
@end menu

@node Hazing
@section Hazing
@cindex Hazing

Welcome.  Those of you who have heard of Common Lisp may doubt the
rumors of its power.  Doubt no more brothers.  The ancient computer
scientist John McCarthy discovered something very powerful in the
depths of MIT.  The faithful have studied and found ways to harness
its power in the years that followed, culminating in two churches:
Common Lisp (https://common-lisp.net/) and Scheme
(http://www.schemers.org/), although there are rumors that there is a
growing mystery cult, Clojure (http://clojure.org/), hiding in the
shadows.

The Church of Scheme and their followers, known as Schemers, strive
for the highest purity, obstaining from sullying themselves with the
problems of common people.  The Church of Common Lisp, whose followers
are known as Lispers, fancy themselves to be pragmatic and have
sacrificed purity for the sake of providing assistance to the hapless
programmers of the world.  No one knows exactly what adherents to the
Cult of Clojure have in mind.

The basic truths of Lisp are common to all these sects, and they are

@enumerate
@item
The REPL: Lisp code is entered into an interactive environment called
the Read Eval Print Loop.
@item
The list: Lisp programs are made of lists.  The first element of a
list is the operator which gives meaning to the expression, and the
rest that follow are the arguments to the operator.
@end enumerate

These truths, simple as they are, are the ultimate source of Lisp's
power.  Each church of Lisp extends this power by having additional
features.

@node Armory
@section Armory
@cindex Armory

If you're still reading this, then you truly want to learn how to use
cl-ana.  You've passed the first test; enter the armory.

First: your Lisp implementation.  SBCL (http://www.sbcl.org/) is at
the moment the only implementation completely supported by cl-ana.
SBCL is available for POSIX platforms like Linux and Mac OS X,
although there is only experimental support for Windows.

Next is your text editor/operating system, Emacs
(https://www.gnu.org/software/emacs/).  Anywhere else you could use
whatever you like to write code, but nothing comes close to Emacs and
SLIME (https://common-lisp.net/project/slime/) for writing and running
Common Lisp code.

@ref{Installation} once you have SBCL, Emacs and SLIME installed for
installing the software dependencies of cl-ana.

ASDF (https://common-lisp.net/project/asdf/) is the primary way Lisp
software dependencies are managed.  The easiest way to allow all of
your personal code to be found is to create a file located at

~/.config/common-lisp/source-registry.conf.d/projects.conf

with the line

(:tree (:home ``path/to/source/directory''))

denoting that any ASDF projects located under
~/path/to/source/directory/ are available to be loaded.

@node Basic Training
@section Basic Training
@cindex Basic Training

Now that you have the proper tools, it's time to get acquainted with
them.  

@node Red Pill
@section Red Pill
@cindex Red Pill

test

@node Manual
@chapter Manual
@cindex Manual

This is the manual@dots{}

@node Index
@unnumbered Index
@printindex cp

@bye
